#!/usr/bin/env python3

from typing import Optional, List, Set, Tuple
import sys
import os
import time
import datetime
import curses
import traceback

char = str
Pos = Tuple[int, int]


class Theme:
    black = "#0d0f18"
    white = "#75869a"
    red = "#ef534f"
    green = "#4d6e2a"
    blue = "#2c7fff"


width: int = 80
height: int = 10
newline_char: char = "↲"
space_char: char = "␣"
typed: List[List[char]] = list()
keys: int = 0
typos: Set[Pos] = set()
typo: Optional[Pos] = None
errors: int = 0
newline: char = " "
start: float = 0


class TypistException(Exception):
    def __init__(self, *args) -> None:
        super().__init__(*args)


def log(*args):
    with open("log.txt", "a") as log:
        print(file=log, *args)


def init_color(c, hex):
    hex = hex.lstrip("#")
    r = int(int(hex[0:2], 16) * 1000 / 255)
    g = int(int(hex[2:4], 16) * 1000 / 255)
    b = int(int(hex[4:6], 16) * 1000 / 255)
    curses.init_color(c, r, g, b)


def main(scr):
    if curses.has_colors() and curses.can_change_color():
        init_color(curses.COLOR_BLACK, Theme.black)
        init_color(curses.COLOR_WHITE, Theme.white)
        init_color(curses.COLOR_RED, Theme.red)
        init_color(curses.COLOR_GREEN, Theme.green)
        init_color(curses.COLOR_BLUE, Theme.blue)
        bg = curses.COLOR_BLACK
    else:
        curses.use_default_colors()
        bg = -1

    curses.init_pair(1, curses.COLOR_RED, bg)
    curses.init_pair(2, curses.COLOR_GREEN, bg)
    curses.init_pair(3, curses.COLOR_BLUE, bg)
    red = curses.color_pair(1)
    green = curses.color_pair(2)
    blue = curses.color_pair(3)
    curses.set_escdelay(25)
    scr.refresh()

    pad = curses.newpad(len(lines) + max(height, 10), width)
    y, x = scr.getmaxyx()
    if x < width:
        raise TypistException("terminal width is too small")
    if y < height:
        raise TypistException("terminal height is too small")
    y, x = (y - height) // 2, (x - width) // 2
    yy, xx = y + height - 1, x + width - 1
    vline, vline_prev = 0, -1
    for i, line in enumerate(lines):
        pad.addstr(i, 0, line)

    def pad_refresh():
        nonlocal vline_prev
        if vline_prev != vline:
            vline_prev = vline
            scr.addch(
                y + height, x + width // 2, " " if vline + height >= len(lines) else "⌄"
            )
            scr.refresh()
        pad.move(cy, cx)
        pad.refresh(vline, 0, y, x, yy, xx)

    def add_typed(ch):
        global start, keys
        if not keys:
            start = time.perf_counter()
        keys += 1
        if cy >= len(typed):
            typed.append(list())
        typed[-1].append(ch)
        if cy < len(lines) and ch == lines[cy][cx]:
            if (cy, cx) in typos:
                pad.addch(ch, blue)
            else:
                pad.addch(ch, green)
        else:
            typos.add((cy, cx))
            global errors, typo
            errors += 1
            if typo is None:
                typo = (cy, cx)
            if ch == "\n":
                ch = newline_char
            elif ch == " ":
                ch = space_char
            pad.addch(ch, red)

    def undo_typed():
        typed[-1].pop()
        if not typed[-1]:
            typed.pop()
        ch = lines[cy][cx] if cy < len(lines) else " "
        if ch == "\n":
            ch = newline
        pad.addch(cy, cx, ch)
        global typo
        if typo == (cy, cx):
            typo = None

    cy, cx = 0, 0
    pad_refresh()
    while True:
        key = scr.getch()
        if key == 27:  # escape; exit
            break
        elif key == 23:  # ctrl+w: erase word
            t = typed[-1]
            while t and t[-1] == " ":
                cx -= 1
                undo_typed()
            while t and t[-1] != " ":
                cx -= 1
                undo_typed()
        elif key == 9:  # tab: reset
            typed.clear()
            typos.clear()
            global typo, errors, keys
            typo = None
            errors = 0
            keys = 0
            vline = 0
            cx, cy = 0, 0
            pad.clear()
            for i, line in enumerate(lines):
                pad.addstr(i, 0, line)
        elif key == curses.KEY_BACKSPACE or key == 127:  # backspace
            if cx == 0 and cy == 0:
                continue
            if cx > 0:
                cx -= 1
                undo_typed()
                if cy != 0 and cy < len(lines):
                    # skip indent backward
                    skip = True
                    for ch in reversed(lines[cy][: cx + 1]):
                        if ch != " ":
                            skip = False
                            break
                    if skip:
                        cy -= 1
                        cx = len(lines[cy]) - 1
            else:
                cy -= 1
                cx = len(lines[cy]) - 1 if cy < len(lines) else width - 1
                undo_typed()
            if cy < vline:
                vline -= 1
        elif key == 10 or (key >= 32 and key <= 126):
            key = chr(key)
            if cy >= len(lines):
                add_typed(key)
                cx += 1
                if cx == width:
                    cx = 0
                    cy += 1
            else:
                skip = lines[cy][cx] == "\n"
                add_typed(key)
                cx += 1
                if cx == len(lines[cy]):
                    cx = 0
                    cy += 1
                if cy == len(lines) and typo is None:
                    break
                if skip:  # skip indent forward
                    for ch in lines[cy]:
                        if ch != " ":
                            break
                        cx += 1
                elif cy == vline + height - 1:
                    vline = min(cy, len(lines) - height)
            if cy >= vline + height:
                vline = cy
        else:
            continue
        pad_refresh()


def fold(text, width):
    while text:
        if len(text) <= width:
            yield text
            return
        w = width
        if text[w] == " " or text[w - 1] != " ":
            while w > 0 and text[w - 1] != " ":
                w -= 1
        if not w:
            w = width
        line = text[:w]
        text = text[w:]
        yield line


punctuation = str.maketrans(
    {
        ord("\t"): "    ",
        ord("…"): "...",
        ord("‘"): "'",
        ord("’"): "'",
        ord("“"): '"',
        ord("”"): '"',
        ord("—"): "-",
    }
)
lines = list()
for line in sys.stdin:
    line = line.translate(punctuation)
    line = line.encode("ascii", "ignore").decode("ascii")  # rm non-ascii chars
    if len(line) > width:
        lines.extend(fold(line, width))
    else:
        lines.append(line)
if not lines:
    print("empty input", file=sys.stderr)
    sys.exit(1)
lines[-1] = lines[-1].rstrip()
height = min(height, len(lines))

with open("/dev/tty", "r+") as tty_file:
    os.dup2(tty_file.fileno(), 0)

try:
    curses.wrapper(main)
except KeyboardInterrupt:
    sys.exit(1)
except TypistException as ex:
    print(ex, file=sys.stderr)
    sys.exit(1)
except Exception:
    traceback.print_exc()
    sys.exit(1)

if keys > 0:
    sec = time.perf_counter() - start
    delta = str(datetime.timedelta(seconds=sec)).removeprefix("0:").removeprefix("00:")
    if "." in delta:
        delta = delta[:-4]
    chars = sum(len(line) for line in typed)
    acc = 100 * (keys - errors) / keys
    raw = (60 * keys) / (5 * sec)
    wpm = (60 * (keys - errors)) / (5 * sec)
    print(f"wpm:      {wpm:.2f}")
    print(f"raw:      {raw:.2f}")
    print(f"accuracy: {acc:.2f}")
    print(f"chars:    {chars}")
    print(f"typed:    {keys}")
    print(f"errors:   {errors}")
    print(f"time:     {delta}")
