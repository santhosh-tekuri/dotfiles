#!/usr/bin/env bash

set -e
set -o pipefail

newline_char=↲
space_char=␣
newline=' '
lang=english
n=50
f=100
caps=none

usage=$(cat <<EOF
USAGE: typist [options...]

-l <language>       monkeytype language or 'os'
                    default english
-q <size>           quote of size (short, medium, long, thick)
-n <words>          number of words
                    default 50
-f <num>            text width
-c                  captalize words randomly
-C                  capitalize all words
-p                  add punctuation
-P <punctuations>    add given punctuations
-s                  add symbols
-S <symbols>        add given symbols
-L                  treat stdin as language
-N                  show newlines
-h                  show this help

shortcuts:
    <tab> to restart
    <esc> twice to quit

to practice some random words:
    typist -l english_5k -n 100
    typist -l code_rust -n 50

to practice capitals:
    typist -c # capitalizes words randomly
    typist -C # capitalizes all words

to practice punctuations:
    typist -p
    typist -P '.,!' # to practice specific punctuations

to practice symbols:
    typist -s
    typist -S '&^^' # to practice specific symbols

to practice quotes:
    typist -q medium

you can provide your own text to type
    yes however | head -n 50 | typist

you can just copy the text generated and use it in your
favorite typing site:
    typist -C | pbcopy
EOF
)

if ! args=$(getopt hLNq:l:n:cCpP:sS:f: $*); then
    >&2 echo "$usage"
    exit 2
fi
set -- $args
while :; do
    case "$1" in
    -h)
        echo "$usage"
        exit 0
        ;;
    -L)
        stdin=lang
        shift
        ;;
    -N)
        newline=$newline_char
        shift
        ;;
    -q)
        qsize=$2
        shift; shift
        ;;
    -l)
        lang=$2
        shift; shift
        ;;
    -n)
        n=$2
        shift; shift
        ;;
    -f)
        f=$2
        shift; shift
        ;;
    -c)
        caps=rand
        shift
        ;;
    -C)
        caps=all
        shift
        ;;
    -p)
        symbols=",.-?!:;'\"()"
        shift
        ;;
    -s)
        symbols='`~!@#$%^&*()-_=+[{}];":,<.>/?\\|'\'
        shift
        ;;
    -P|-S)
        symbols="$2"
        shift; shift
        ;;
    --)
        shift; break
        ;;
    esac
done

if [ ! -t 0 ]; then
    text=$(cat | tr "’“”" "'\"\"")
elif [ "$qsize" != "" ]; then
    case "$qsize" in
        short)
            qsize='length >= 1 && length <= 100' ;;
        medium)
            qsize='length >= 101 && length <= 300' ;;
        long)
            qsize='length >= 301 && length <= 600' ;;
        thick)
            qsize='length >= 601' ;;
        *)
            >&2 echo invalid quote size. valid are short, medium, long, thick
            exit 2
            ;;
    esac
    file=~/.local/share/typist/quotes
    if [ ! -f $file ]; then
        >&2 echo downloading quotes
        mkdir -p $(dirname $file)
        curl -s --fail https://raw.githubusercontent.com/monkeytypegame/monkeytype/refs/heads/master/frontend/static/quotes/english.json | jq -r '.quotes[].text | sub("\n";" ";"g")' > $file
    fi
    text=$(awk "$qsize" $file | shuf -n1)
else
    if [ "$lang" == "os" ]; then
        file="/usr/share/dict/words"
    else
        file=~/.local/share/typist/languages/$lang
        if [ ! -f $file ]; then
            >&2 echo downloading $lang
            mkdir -p $(dirname $file)
            curl -s --fail https://raw.githubusercontent.com/monkeytypegame/monkeytype/refs/heads/master/frontend/static/languages/$lang.json | jq -r '.words[]' > $file
        fi
    fi

    text=""
    while IFS='' read -r word; do
        if [ $caps == "all" ] || ( [ $caps == "rand" ] && (( $RANDOM % 2 == 1 ))); then
            word=$(echo ${word:0:1} | tr '[:lower:]' '[:upper:]')${word:1}
        fi
        if [ "$symbols" != "" ] && (( $RANDOM % 2 == 1)); then
            i=$(( $RANDOM % ${#symbols} ))
            ch="${symbols:i:1}"
            case "$ch" in
                "&"|"@"|"#"|"("|"{"|'['|'<')
                    text+=" $ch$word"
                    ;;
                "_")
                    text+="_$word"
                    ;;
                "-")
                    text+=" - $word"
                    ;;
                \`|"'"|"\"")
                    text+=" $ch$word$ch"
                    ;;
                *)
                    text+=" $word$ch"
                    ;;
            esac
        else 
            text+=" $word"
        fi
    done < <(shuf -n $n $file)
    text=${text:1}
fi

if [ ! -t 1 ]; then
    echo "$text"
    exit
fi

if [ -t 0 ]; then
    lines=()
    while IFS='' read -r line; do
        lines+=(${#line})
    done < <(echo "$text" | fold -s -w $f)
else
    case "$stdin" in
        "lang")
            text=$(echo "$text" | tr '\n' ' ' | awk '{$1=$1};1')
            lines=()
            while IFS='' read -r line; do
                lines+=(${#line})
            done < <(echo "$text" | fold -s -w $f)
            ;;
        *)
            lines=()
            indent=0
            while IFS='' read -r line; do
                ((indent += $(echo "$line" | awk '{print match($0,/[^ ]|$/)-1}')))
                while IFS='' read -r ln; do
                    lines+=(${#ln})
                done < <(echo "$line" | fold -s -w $f)
                last=${#lines[@]}
                ((last--))
                ((lines[$last]++))
            done <<< "$text"
            last=${#lines[@]}
            ((last--))
            ((lines[$last]--))
            ;;
    esac
fi
chars=${#text}

xx=$(( ( $(tput cols) - $f ) / 2))
((xx++))
if ((xx<0)); then
    >&2 echo text width too long
    exit 1
fi
yy=$(( ( $(tput lines) - ${#lines[@]} ) / 2 ))
((yy++))
if ((yy<0)); then
    >&2 echo text height too long
    exit 1
fi

if [ ! -t 0 ]; then
    exec 0<>/dev/tty
fi
stty -echo # diable echo
printf '\e[?1049h' # start altscreen
printf '\e[2J' # clear screen
printf '\e[?25h' # show cursor
printf '\033[6 q' # change cursor to I-beam

cleanup() {
    printf '\e[?1049l' # end altscreen
    stty echo # enable echo
    if [[ "$time" -ne "" ]]; then
        ((chars-=indent))
        printf "WPM   %s\n" $(bc <<< "scale=2; $chars * 60 / 5 / $time" )
        printf "ACC   %s\n" $(bc <<< "scale=2; $chars * 100 / $keys")
        printf "ERR   %s\n" $errors
        printf "CHARS %s\n" $chars
        printf "TIME  %s sec\n" $time
    fi
}
trap cleanup EXIT

redraw() {
    clear
    i=0
    y=$yy
    for line in "${lines[@]}"; do
        printf '\e[%d;%dH' $y $xx # set cursor pos
        echo -n "${text:i:line}"
        ((i+=line))
        if [[ "${text:i-1:1}" == $'\n' ]]; then
            printf '\e[%d;%dH' $y $(($xx+line-1)) # set cursor pos
            echo -n $newline
        fi
        ((y++))
    done
    printf '\e[%d;%dH' $yy $xx # set cursor pos
    i=0
    typed=""
    keys=0
    errors=0
}
redraw

while IFS='' read -d '' -rsn1 char; do
    ((keys++))
    if (( keys == 1 )); then
        SECONDS=0
    fi 
    case "$char" in
        $'\0') # ener
            char=$'\n'
            ;;
        $'\e') # escape
            read -rsn1 ignore
            if [[ "$ignore" == $'\e' ]]; then
                break # double escape
            fi
            read -rsn1 ignore # arrow keys
            continue ;;
        $'\t') # tab -> reset
            redraw
            continue ;;
    esac
    if [[ "$char" == $'\x7f' ]]; then
        if [[ $i == 0 ]]; then
            continue
        fi
        typed=${typed:0:${#typed}-1}
        ((i--))
        # skip indent backward
        if [[ "${text:i:1}" == ' ' ]]; then
            while true; do
                if ((i == 0 )); then
                    break
                fi
                ch="${text:i-1:1}"
                if [[ "$ch" != ' ' ]] && [[ "$ch" != $'\n' ]]; then
                    break
                fi
                ((i--))
                typed=${typed:0:${#typed}-1}
                if [[ "$ch" == $'\n' ]]; then
                    break
                fi
            done
        fi
    else
        typed+="$char"
        if [[ "$char" == "${text:i:1}" ]]; then
            printf '\e[32m%c\e[m' "$char"
        else
            ((errors++))
            if [[ "$char" == " " ]]; then
                printf '\e[31m%s\e[m' "$space_char"
            elif [[ "$char" == $'\n' ]]; then
                printf '\e[31m%s\e[m' "$newline_char"
            else
                printf '\e[31m%c\e[m' "$char"
            fi
        fi
        ((i++))
        # skip indent forward
        if [[ "${text:i-1:1}" == $'\n' ]]; then
            while true; do
                if ((i >= chars)); then
                    break
                fi
                if [[ "${text:i:1}" != ' ' ]]; then
                    break
                fi
                ((i++))
                typed+=' '
            done
        fi
    fi

    if (( $i == $chars )) && [[ "$typed" == "$text" ]]; then
        time=$SECONDS
        break
    fi

    # update cursor pos
    y=0
    x=$i
    for line in "${lines[@]}"; do
        if (( $x < $line )); then
            break
        fi
        ((y++))
        x=$(( $x - $line )) 
    done
    while (( x > f )); do
        ((x-=f))
        ((y++))
    done
    ((x+=xx))
    ((y+=yy))
    printf '\e[%d;%dH' $y $x # set cursor pos

    if [[ "$char" == $'\x7f' ]]; then
        ch=' '
        if (( $i < ${#text} )); then
            ch="${text:i:1}"
        fi
        if [[ "$ch" == $'\n' ]]; then
            ch=$newline
        fi
        printf '%s' "$ch"
        printf '\e[%d;%dH' $y $x # set cursor pos
    fi
done
