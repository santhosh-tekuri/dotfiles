#!/usr/bin/env python3

from typing import Optional, List, Set, Tuple
import sys
import os
import time
import datetime
import curses
import traceback

char = str
Pos = Tuple[int, int]


class Theme:
    black = "#0d0f18"
    white = "#75869a"
    red = "#ef534f"
    green = "#4d6e2a"
    blue = "#2c7fff"


translations = {
    "\t": "    ",
    "…": "...",
    "‘": "'",
    "’": "'",
    "“": '"',
    "”": '"',
    "—": "-",
}

width: int = 80
height: int = 10
newline_char: char = "↲"
space_char: char = "␣"
lines = list()
typed: List[List[char]] = list()
typos: Set[Pos] = set()
typo: Optional[Pos] = None
errors: int = 0
newline: char = " "
start: float = 0


class TypistException(Exception):
    def __init__(self, *args) -> None:
        super().__init__(*args)


def log(*args):
    with open("log.txt", "a") as log:
        print(file=log, *args)


def rgb(hex):
    return (int(int(hex[i : i + 2], 16) * 1000 / 255) for i in range(1, 6, 2))


class Screen:
    def __init__(self, scr) -> None:
        self.scr = scr
        self.init_width()
        self.init_input()
        self.init_height()
        self.init_tty()
        self.init_theme()
        self.keys = 0

    def init_tty(self):
        with open("/dev/tty", "r+") as tty_file:
            os.dup2(tty_file.fileno(), 0)

    def init_width(self):
        global width
        width = min(width, curses.COLS - 10)
        if width < 20:
            raise TypistException("terminal width is too small")

    def init_input(self):
        trans = str.maketrans({ord(k): v for k, v in translations.items()})
        for line in sys.stdin:
            line = line.translate(trans)
            line = line.encode("ascii", "ignore").decode("ascii")  # rm non-ascii chars
            if len(line) > width:
                lines.extend(fold(line, width))
            else:
                lines.append(line)
        if not lines:
            raise TypistException("empty input")
        lines[-1] = lines[-1].rstrip()

    def init_height(self):
        global height
        height = min(height, len(lines), curses.LINES - 1)
        if height < 1:
            raise TypistException("terminal height is too small")

    def init_theme(self):
        if curses.has_colors() and curses.can_change_color():
            curses.init_color(curses.COLOR_BLACK, *rgb(Theme.black))
            curses.init_color(curses.COLOR_WHITE, *rgb(Theme.white))
            curses.init_color(curses.COLOR_RED, *rgb(Theme.red))
            curses.init_color(curses.COLOR_GREEN, *rgb(Theme.green))
            curses.init_color(curses.COLOR_BLUE, *rgb(Theme.blue))
            bg = curses.COLOR_BLACK
        else:
            curses.use_default_colors()
            bg = -1

        curses.init_pair(1, curses.COLOR_RED, bg)
        curses.init_pair(2, curses.COLOR_GREEN, bg)
        curses.init_pair(3, curses.COLOR_BLUE, bg)

        self.red = curses.color_pair(1)
        self.green = curses.color_pair(2)
        self.blue = curses.color_pair(3)

    def run(self):
        scr = self.scr
        curses.set_escdelay(25)
        scr.refresh()

        pad = curses.newpad(len(lines) + max(height, 10), width)
        y, x = scr.getmaxyx()
        y, x = (y - height) // 2, (x - width) // 2
        yy, xx = y + height - 1, x + width - 1
        vline, vline_prev = 0, -1
        for i, line in enumerate(lines):
            pad.addstr(i, 0, line)

        def pad_refresh():
            nonlocal vline_prev
            if vline_prev != vline:
                vline_prev = vline
                scr.addch(
                    y + height,
                    x + width // 2,
                    " " if vline + height >= len(lines) else "⌄",
                )
                scr.refresh()
            pad.move(cy, cx)
            pad.refresh(vline, 0, y, x, yy, xx)

        def add_typed(ch):
            global start
            if not self.keys:
                start = time.perf_counter()
            self.keys += 1
            if cy >= len(typed):
                typed.append(list())
            typed[-1].append(ch)
            if cy < len(lines) and ch == lines[cy][cx]:
                if (cy, cx) in typos:
                    pad.addch(ch, self.blue)
                else:
                    pad.addch(ch, self.green)
            else:
                typos.add((cy, cx))
                global errors, typo
                errors += 1
                if typo is None:
                    typo = (cy, cx)
                if ch == "\n":
                    ch = newline_char
                elif ch == " ":
                    ch = space_char
                pad.addch(ch, self.red)

        def undo_typed():
            typed[-1].pop()
            if not typed[-1]:
                typed.pop()
            ch = lines[cy][cx] if cy < len(lines) else " "
            if ch == "\n":
                ch = newline
            pad.addch(cy, cx, ch)
            global typo
            if typo == (cy, cx):
                typo = None

        cy, cx = 0, 0
        pad_refresh()
        while True:
            key = scr.getch()
            if key == 27:  # escape; exit
                break
            elif key == 23:  # ctrl+w: erase word
                t = typed[-1]
                while t and t[-1] == " ":
                    cx -= 1
                    undo_typed()
                while t and t[-1] != " ":
                    cx -= 1
                    undo_typed()
            elif key == 9:  # tab: reset
                typed.clear()
                typos.clear()
                global typo, errors
                typo = None
                errors = 0
                self.keys = 0
                vline = 0
                cx, cy = 0, 0
                pad.clear()
                for i, line in enumerate(lines):
                    pad.addstr(i, 0, line)
            elif key == curses.KEY_BACKSPACE or key == 127:  # backspace
                if cx == 0 and cy == 0:
                    continue
                if cx > 0:
                    cx -= 1
                    undo_typed()
                    if cy != 0 and cy < len(lines):
                        # skip indent backward
                        skip = True
                        for ch in reversed(lines[cy][: cx + 1]):
                            if ch != " ":
                                skip = False
                                break
                        if skip:
                            cy -= 1
                            cx = len(lines[cy]) - 1
                else:
                    cy -= 1
                    cx = len(lines[cy]) - 1 if cy < len(lines) else width - 1
                    undo_typed()
                if cy < vline:
                    vline -= 1
            elif key == 10 or (key >= 32 and key <= 126):
                key = chr(key)
                if cy >= len(lines):
                    add_typed(key)
                    cx += 1
                    if cx == width:
                        cx = 0
                        cy += 1
                else:
                    skip = lines[cy][cx] == "\n"
                    add_typed(key)
                    cx += 1
                    if cx == len(lines[cy]):
                        cx = 0
                        cy += 1
                    if cy == len(lines) and typo is None:
                        break
                    if skip:  # skip indent forward
                        for ch in lines[cy]:
                            if ch != " ":
                                break
                            cx += 1
                    if cy == vline + height - 1:
                        vline = min(cy, len(lines) - height)
                if cy >= vline + height:
                    vline = cy
            else:
                continue
            pad_refresh()
        return self.results() if self.keys > 0 else ""

    def results(self):
        sec = time.perf_counter() - start
        chars = sum(len(line) for line in typed)
        acc = 100 * (self.keys - errors) / self.keys
        raw = (60 * self.keys) / (5 * sec)
        wpm = (60 * (self.keys - errors)) / (5 * sec)
        delta = str(datetime.timedelta(seconds=sec))
        delta = delta.removeprefix("0:").removeprefix("00:")
        if "." in delta:
            delta = delta[:-4]
        return (
            f"wpm:      {wpm:.2f}\n"
            f"raw:      {raw:.2f}\n"
            f"accuracy: {acc:.2f}\n"
            f"chars:    {chars}\n"
            f"typed:    {self.keys}\n"
            f"errors:   {errors}\n"
            f"time:     {delta}\n"
        )


def fold(text, width):
    while text:
        if len(text) <= width:
            yield text
            return
        w = width
        if text[w] == " " or text[w - 1] != " ":
            while w > 0 and text[w - 1] != " ":
                w -= 1
        if not w:
            w = width
        line = text[:w]
        text = text[w:]
        yield line


try:
    results = curses.wrapper(lambda scr: Screen(scr).run())
    print(results, end="")
except KeyboardInterrupt:
    sys.exit(1)
except TypistException as ex:
    print(ex, file=sys.stderr)
    sys.exit(1)
except Exception:
    traceback.print_exc()
    sys.exit(1)
