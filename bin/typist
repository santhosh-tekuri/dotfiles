#!/usr/bin/env bash

set -e
set -o pipefail

lang=english
n=50
f=100
caps=none

usage=$(cat <<EOF
USAGE: typist [options...]

-l <language>       monkeytype language
                    default english
-q <size>           quote of size (short, medium, long, thick)
-n <words>          number of words
                    default 50
-f <num>            fold after num chars
-c                  captalize words randomly
-C                  capitalize all words
-p                  add punctuation
-P <punctuation>    add given punctuation
-s                  add symbols
-s <symbols>        add given symbols
-h                  show this help
EOF
)

args=$(getopt hq:l:n:cCpP:sS: $*)
if [ $? -ne 0 ]; then
    >&2 echo "$usage"
    exit 2
fi
set -- $args
while :; do
    case "$1" in
    -h)
        echo "$usage"
        exit 0
        ;;
    -q)
        qsize=$2
        shift; shift
        ;;
    -l)
        lang=$2
        shift; shift
        ;;
    -n)
        n=$2
        shift; shift
        ;;
    -c)
        caps=rand
        shift
        ;;
    -C)
        caps=all
        shift
        ;;
    -p)
        symbols=",.-?!:;'\"()"
        shift
        ;;
    -s)
        symbols='`~!@#$%^&*()-_=+[{}];":,<.>/?\\|'\'
        shift
        ;;
    -P|-S)
        symbols="$2"
        shift; shift
        ;;
    --)
        shift; break
        ;;
    esac
done

if [ ! -t 0 ]; then
    text=$(cat | tr '\n' ' ' | awk '{$1=$1};1')
    exec 0<>/dev/tty
elif [ "$qsize" != "" ]; then
    case "$qsize" in
        short)
            qsize='length >= 1 && length <= 100'
            ;;
        medium)
            qsize='length >= 101 && length <= 300'
            ;;
        long)
            qsize='length >= 301 && length <= 600'
            ;;
        thick)
            qsize='length >= 601'
            ;;
        *)
            >&2 echo invalid quote size. valid are short, medium, long, thick
            exit 2
            ;;
    esac
    file=~/.local/share/typist/quotes
    if [ ! -f $file ]; then
        >&2 echo downloading quotes
        mkdir -p $(dirname $file)
        curl -sS --fail https://raw.githubusercontent.com/monkeytypegame/monkeytype/refs/heads/master/frontend/static/quotes/english.json | jq -r '.quotes[].text | sub("\n";" ";"g")' > $file
    fi
    text=$(awk "$qsize" $file | shuf -n1)
else
    if [ "$lang" == "os" ]; then
        file="/usr/share/dict/words"
    else
        file=~/.local/share/typist/languages/$lang
        if [ ! -f $file ]; then
            >&2 echo downloading $lang
            mkdir -p $(dirname $file)
            curl -sS --fail https://raw.githubusercontent.com/monkeytypegame/monkeytype/refs/heads/master/frontend/static/languages/$lang.json | jq -r '.words[]' > $file
        fi
    fi

    text=""
    while IFS='' read -r word; do
        if [ $caps == "all" ] || ( [ $caps == "rand" ] && (( $RANDOM % 2 == 1 ))); then
            word=$(echo ${word:0:1} | tr '[:lower:]' '[:upper:]')${word:1}
        fi
        if [ "$symbols" != "" ] && (( $RANDOM % 2 == 1)); then
            i=$(( $RANDOM % ${#symbols} ))
            ch="${symbols:i:1}"
            case "$ch" in
                "&"|"@"|"#"|"("|"{"|'['|'<')
                    text+=" $ch$word"
                    ;;
                "_")
                    text+="_$word"
                    ;;
                "-")
                    text+=" - $word"
                    ;;
                \`|"'"|"\"")
                    text+=" $ch$word$ch"
                    ;;
                *)
                    text+=" $word$ch"
                    ;;
            esac
        else 
            text+=" $word"
        fi
    done < <(shuf -n $n $file)
    text=${text:1}
fi

if [ ! -t 1 ]; then
    echo "$text"
    exit
fi

chars=${#text}
lines=()
while IFS='' read -r line; do
    lines+=(${#line})
done < <(echo "$text" | fold -s -w $f)

xx=$(( ( $(tput cols) - $f ) / 2))
yy=$(( ( $(tput lines) - ${#lines[@]} ) / 2 ))

stty -echo # diable echo
printf '\e[?1049h' # start altscreen
printf '\e[2J' # clear screen
printf '\e[?25h' # show cursor
printf '\033[6 q' # change cursor to I-beam

cleanup() {
    printf '\e[?1049l' # end altscreen
    stty echo # enable echo
    if [[ "$time" -ne "" ]]; then
        printf "WPM   %s\n" $(bc <<< "scale=2; $chars * 60 / 5 / $time" )
        printf "ACC   %s\n" $(bc <<< "scale=2; $chars * 100 / $keys")
        printf "ERR   %s\n" $errors
        printf "CHARS %s\n" $chars
        printf "TIME  %s sec\n" $time
    fi
}
trap cleanup EXIT

redraw() {
    clear
    i=0
    y=$yy
    for line in "${lines[@]}"; do
        printf '\e[%d;%dH' $y $xx # set cursor pos
        echo -n "${text:i:line}"
        ((i+=line))
        ((y++))
    done
    printf '\e[%d;%dH' $yy $xx # set cursor pos
    i=0
    typed=""
    keys=0
    errors=0
}
redraw

while IFS='' read -rsn1 char; do
    ((keys++))
    if (( keys == 1 )); then
        SECONDS=0
    fi 
    case "$char" in
        $'\0') # ener
            break ;;
        $'\e') # arrow keys
            read -rsn2 ignore
            continue ;;
        $'\t') # tab -> reset
            redraw
            continue ;;
    esac
    if [[ "$char" == $'\x7f' ]]; then
        if [[ $i == 0 ]]; then
            continue
        fi
        typed=${typed:0:${#typed}-1}
        ((i--))
    else
        typed+="$char"
        if [[ "$char" == "${text:i:1}" ]]; then
            printf '\e[32m%c\e[m' "$char"
        else
            ((errors++))
            if [[ "$char" == " " ]]; then
                printf '\e[41m%c\e[m' "$char"
            else
                printf '\e[31m%c\e[m' "$char"
            fi
        fi
        ((i++))
    fi

    if (( $i == $chars )) && [[ "$typed" == "$text" ]]; then
        time=$SECONDS
        break
    fi

    # update cursor pos
    y=0
    x=$i
    for line in "${lines[@]}"; do
        if (( $x < $line )); then
            break
        fi
        ((y++))
        x=$(( $x - $line )) 
    done
    while (( x > f )); do
        ((x-=f))
        ((y++))
    done
    ((x+=xx))
    ((y+=yy))
    printf '\e[%d;%dH' $y $x # set cursor pos

    if [[ "$char" == $'\x7f' ]]; then
        if (( $i < ${#text} )); then
            printf '%c' "${text:i:1}"
        else
            printf ' '
        fi
        printf '\e[%d;%dH' $y $x # set cursor pos
    fi
done
